# 商业化方案设计

## 一、收费模式推荐

### 推荐方案：订阅制 + 按量计费混合模式

**方案A：订阅制（推荐）⭐⭐⭐⭐⭐**
- **基础版**：免费，每日限制搜索次数（如50次/天）
- **标准版**：¥9.9/月，每日500次搜索，支持1个平台
- **高级版**：¥19.9/月，每日2000次搜索，支持所有平台
- **专业版**：¥39.9/月，无限搜索，所有平台，优先技术支持

**方案B：按量计费**

- 免费额度：每日50次搜索
- 超出部分：¥0.01/次搜索
- 适合偶尔使用的用户

**方案C：混合模式（最灵活）**

- 基础订阅 + 超出按量计费
- 例如：¥9.9/月包含500次，超出部分¥0.01/次

---

## 二、用户认证与授权系统

### 1. API Key认证（简化方案）

**推荐：API Key认证，无需注册登录**

```python
# API Key模型
class APIKey(BaseModel):
    id: int
    api_key: str  # 唯一标识符，如：czbk_xxxxxxxxxxxx
    plan: str  # free, standard, premium, pro
    created_at: datetime
    expires_at: Optional[datetime]  # 订阅到期时间（可选）
    total_queries: int  # 总查询次数
    daily_queries: int  # 今日查询次数
    daily_limit: int  # 每日查询限制
    is_active: bool  # 是否激活
```

**API设计：**
```python
# 生成API Key（管理员或购买后自动生成）
POST /api/admin/generate-key
{
    "plan": "standard",  # free, standard, premium, pro
    "expires_days": 30  # 可选，订阅天数
}
# 返回: { "api_key": "czbk_xxxxxxxxxxxx", "plan": "standard", "daily_limit": 500 }

# 查询API Key信息
GET /api/key/info
Headers: X-API-Key: czbk_xxxxxxxxxxxx
# 返回: { "plan": "standard", "daily_queries": 123, "daily_limit": 500, "expires_at": "2025-12-31" }

# 重置每日查询次数（自动，每日0点执行）
# 或手动重置
POST /api/admin/reset-daily-queries
{
    "api_key": "czbk_xxxxxxxxxxxx"
}
```

### 2. 权限控制中间件

```python
from fastapi import HTTPException, Depends, Header
from typing import Optional

async def get_api_key(x_api_key: Optional[str] = Header(None, alias="X-API-Key")):
    """从请求头获取API Key"""
    if not x_api_key:
        raise HTTPException(
            status_code=401, 
            detail="API Key required. Please provide X-API-Key header."
        )
    return x_api_key

async def verify_api_key(api_key: str = Depends(get_api_key)):
    """验证API Key并返回Key信息"""
    key_info = get_api_key_info(api_key)
    if not key_info or not key_info.is_active:
        raise HTTPException(status_code=401, detail="Invalid or inactive API Key")
    
    # 检查是否过期
    if key_info.expires_at and key_info.expires_at < datetime.now():
        raise HTTPException(status_code=403, detail="API Key has expired")
    
    return key_info

async def check_search_limit(key_info: APIKey = Depends(verify_api_key)):
    """检查搜索次数限制"""
    # 检查每日限制
    if key_info.daily_limit > 0 and key_info.daily_queries >= key_info.daily_limit:
        raise HTTPException(
            status_code=429, 
            detail=f"Daily search limit exceeded. Limit: {key_info.daily_limit}/day. "
                   f"Used: {key_info.daily_queries}. Reset at midnight."
        )
    return key_info

@app.post("/api/search")
async def search(
    request: SearchRequest,
    key_info: APIKey = Depends(check_search_limit)
):
    # 执行搜索
    result = perform_search(request)
    
    # 更新查询次数
    increment_query_count(key_info.api_key)
    
    return result
```

### 3. API Key生成规则

```python
import secrets
import hashlib
from datetime import datetime, timedelta

def generate_api_key(plan: str, prefix: str = "czbk") -> str:
    """生成API Key"""
    # 生成随机字符串
    random_part = secrets.token_urlsafe(16)  # 22个字符
    # 组合：前缀_随机字符串
    api_key = f"{prefix}_{random_part}"
    return api_key

def create_api_key(plan: str, expires_days: Optional[int] = None) -> APIKey:
    """创建新的API Key"""
    api_key = generate_api_key(plan)
    expires_at = None
    if expires_days:
        expires_at = datetime.now() + timedelta(days=expires_days)
    
    # 根据计划设置每日限制
    daily_limits = {
        'free': 50,
        'standard': 500,
        'premium': 2000,
        'pro': -1  # 无限
    }
    
    key_info = APIKey(
        api_key=api_key,
        plan=plan,
        created_at=datetime.now(),
        expires_at=expires_at,
        total_queries=0,
        daily_queries=0,
        daily_limit=daily_limits.get(plan, 50),
        is_active=True
    )
    
    # 保存到数据库
    save_api_key(key_info)
    return key_info
```

---

## 三、数据隔离策略

### 推荐方案：平台共享 + 用户贡献隔离

**策略说明：**
1. **公共答案库**：所有用户共享，由系统维护
2. **用户贡献库**：用户上传的题目答案，仅该用户可见
3. **搜索优先级**：用户贡献库 > 公共答案库

**数据库设计：**

```sql
-- API Key表（替代用户表）
CREATE TABLE api_keys (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    api_key TEXT NOT NULL UNIQUE,
    plan TEXT NOT NULL DEFAULT 'free',  -- free, standard, premium, pro
    created_at INTEGER NOT NULL,
    expires_at INTEGER,  -- 订阅到期时间戳（可选）
    total_queries INTEGER DEFAULT 0,
    daily_queries INTEGER DEFAULT 0,
    daily_limit INTEGER DEFAULT 50,
    last_reset_date DATE,  -- 上次重置日期
    is_active INTEGER DEFAULT 1,  -- 0=禁用, 1=激活
    INDEX(api_key),
    INDEX(last_reset_date)
);

-- 公共答案库（所有API Key共享）
CREATE TABLE public_questions (
    id INTEGER PRIMARY KEY,
    question_id TEXT NOT NULL,
    platform TEXT NOT NULL,
    type TEXT NOT NULL,
    question_content TEXT NOT NULL,
    answer TEXT,
    solution TEXT,
    options TEXT,
    source TEXT DEFAULT 'system',  -- system, api_upload
    created_at INTEGER,
    UNIQUE(question_id, platform)
);

-- API Key贡献库（按API Key隔离）
CREATE TABLE api_key_questions (
    id INTEGER PRIMARY KEY,
    api_key TEXT NOT NULL,
    question_id TEXT NOT NULL,
    platform TEXT NOT NULL,
    type TEXT NOT NULL,
    question_content TEXT NOT NULL,
    answer TEXT,
    solution TEXT,
    options TEXT,
    created_at INTEGER,
    FOREIGN KEY (api_key) REFERENCES api_keys(api_key),
    UNIQUE(api_key, question_id, platform)
);

-- 搜索记录（用于统计和限制）
CREATE TABLE search_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    api_key TEXT NOT NULL,
    question_id TEXT,
    platform TEXT,
    search_date DATE,
    created_at INTEGER,
    FOREIGN KEY (api_key) REFERENCES api_keys(api_key),
    INDEX(api_key, search_date)
);
```

**搜索逻辑：**

```python
async def search_answer(request: SearchRequest, api_key: str):
    results = []
    
    # 1. 优先搜索该API Key的贡献库
    key_result = search_api_key_questions(api_key, request)
    if key_result:
        results.append({
            **key_result,
            "source": "api_key",
            "confidence": 1.0
        })
    
    # 2. 搜索公共答案库
    public_result = search_public_questions(request)
    if public_result:
        results.append({
            **public_result,
            "source": "public",
            "confidence": calculate_confidence(public_result, request)
        })
    
    # 3. 返回最佳匹配
    return select_best_match(results)
```

---

## 四、平台优先级策略

### 推荐方案：智能匹配 + 用户偏好

**策略：**
1. **精确匹配优先**：questionId精确匹配 > 内容相似度匹配
2. **平台优先级**：用户当前使用的平台优先
3. **跨平台搜索**：如果当前平台没找到，搜索其他平台

```python
async def search_with_priority(request: SearchRequest, api_key: str):
    # 1. 如果指定了平台，优先在该平台搜索
    if request.platform:
        result = search_in_platform(request.platform, request, api_key)
        if result and result.confidence > 0.8:
            return result
    
    # 2. 搜索该API Key最近使用的平台（从搜索记录中获取）
    preferred_platform = get_api_key_preferred_platform(api_key)
    if preferred_platform:
        result = search_in_platform(preferred_platform, request, api_key)
        if result and result.confidence > 0.8:
            return result
    
    # 3. 全平台搜索，按相似度排序
    all_results = search_all_platforms(request, api_key)
    if all_results:
        # 按置信度排序，返回最佳匹配
        return max(all_results, key=lambda x: x.confidence)
    
    return None
```

---

## 五、题目格式差异处理

### 推荐方案：标准化 + 格式转换器

**策略：**
1. **统一数据格式**：所有平台题目转换为统一格式存储
2. **格式转换器**：每个平台适配器负责格式转换
3. **智能匹配**：使用文本相似度算法处理格式差异

```python
# 统一题目格式
class StandardQuestion(BaseModel):
    question_id: str
    platform: str
    type: str  # 0-4
    question_content: str
    options: Optional[List[str]] = None
    answer: Optional[str] = None
    solution: Optional[str] = None

# 格式转换器
class QuestionNormalizer:
    @staticmethod
    def normalize(question: dict, platform: str) -> StandardQuestion:
        """将平台特定格式转换为标准格式"""
        if platform == 'czbk':
            return normalize_czbk(question)
        elif platform == 'chaoxing':
            return normalize_chaoxing(question)
        # ...
    
    @staticmethod
    def normalize_czbk(question: dict) -> StandardQuestion:
        # 传智播客格式转换逻辑
        return StandardQuestion(
            question_id=question.get('id') or question.get('questionId'),
            platform='czbk',
            type=question.get('questionType', '0'),
            question_content=question.get('questionContent', ''),
            options=[opt.get('text', '') for opt in question.get('questionOptionList', [])],
            answer=question.get('answer', ''),
            solution=question.get('solution', '')
        )
```

**相似度匹配：**
```python
from difflib import SequenceMatcher
import jieba

def calculate_similarity(text1: str, text2: str) -> float:
    """计算文本相似度"""
    # 方法1: 简单字符串相似度
    similarity1 = SequenceMatcher(None, text1, text2).ratio()
    
    # 方法2: 分词后相似度（更适合中文）
    words1 = set(jieba.cut(text1))
    words2 = set(jieba.cut(text2))
    if not words1 or not words2:
        return similarity1
    
    similarity2 = len(words1 & words2) / len(words1 | words2)
    
    # 综合两种方法
    return (similarity1 * 0.3 + similarity2 * 0.7)

def fuzzy_search(question_content: str, threshold: float = 0.8):
    """模糊搜索题目"""
    results = []
    for question in all_questions:
        similarity = calculate_similarity(
            question.question_content, 
            question_content
        )
        if similarity >= threshold:
            results.append({
                **question,
                'confidence': similarity
            })
    return sorted(results, key=lambda x: x['confidence'], reverse=True)
```

---

## 六、前端使用方式设计（融合方案）

### 1. 设计理念

**融合 auto_answer.user.js 和完整版 chaoxing.js 的优势：**

**从 auto_answer.user.js 借鉴：**
- 强大的控制面板功能
- 支持多种题型（单选、多选、判断、填空、简答）
- 本地答案库缓存（GM_getValue存储）
- 答题日志记录
- 批量自动答题
- 配置管理完善

**从完整版 chaoxing.js 借鉴（Vue 3 + Ant Design Vue架构）：**
- **现代化UI框架**：Vue 3 + Ant Design Vue（Antdv），提供专业界面
- **组件化设计**：可拖拽悬浮面板、标签页切换
- **状态管理**：Pinia状态管理，配置持久化
- **日志系统**：实时日志显示，支持不同类型日志（success、info、warning、error）
- **配置管理**：可视化配置界面，支持平台特定配置
- **题目列表**：表格展示题目和答案，支持查看详情
- **响应式设计**：适配不同屏幕尺寸

**融合后的核心特点：**
- **双重查询策略**：本地答案库（GM_getValue）优先 + 云端API补充 + AI答题
- **渐进式功能**：基础查询（简洁按钮） + 高级功能（控制面板）
- **灵活配置**：用户可选择使用模式（简洁模式/完整模式）
- **现代化UI**：可选的Vue组件化界面（参考chaoxing.js）或轻量级按钮（参考简单chaoxing.js）

### 2. 前端架构设计

#### 2.1 架构方案选择

**方案A：轻量级架构（推荐用于传智播客）**
- **特点**：简洁快速，类似简单版chaoxing.js
- **实现**：原生JavaScript，固定按钮 + 弹窗
- **优点**：体积小、加载快、兼容性好
- **适用**：传智播客平台，快速查询需求

**方案B：现代化架构（可选，参考完整版chaoxing.js）**
- **特点**：专业界面，Vue 3 + Ant Design Vue（Antdv）
- **实现**：组件化开发，可拖拽面板
- **优点**：用户体验好、功能丰富、可扩展性强、中文文档完善
- **适用**：需要复杂配置和管理的场景

**推荐策略**：
- 传智播客：优先使用轻量级架构（方案A）
- 如需高级功能：可集成Vue组件（方案B的部分功能）

#### 2.2 核心模块设计

**1. 初始化模块**
- 页面加载检测（`document.readyState`）
- 路由变化监听（SPA应用）
- API Key配置检查
- 本地答案库加载（GM_getValue）

**2. 题目识别模块**
- 平台适配器模式（参考chaoxing.js的BaseQuestionHandler）
- 支持iframe嵌套（参考IframeUtils）
- DOM结构解析
- 题目类型识别

**3. 答案查询模块**
- 三级查询策略：本地库 → 云端API → AI答题
- 查询结果缓存
- 错误重试机制

**4. 结果展示模块**
- 轻量级：固定弹窗（参考简单chaoxing.js）
- 现代化：Vue组件表格（参考完整chaoxing.js）

**5. 自动填充模块**
- 题型适配器
- 填充验证
- 错误处理

**6. 控制面板模块（可选）**
- 配置管理（参考chaoxing.js的useConfigStore）
- 日志系统（参考chaoxing.js的useLogStore）
- 题目列表（参考chaoxing.js的QuestionTable）
- 使用统计

#### 2.3 功能层次设计

**第一层：基础查询功能（默认启用，轻量级）**
- 右下角固定查询按钮
- 点击查询当前题目答案
- 右上角结果弹窗展示
- 支持手动填充

**第二层：自动答题功能（可选启用）**
- 自动识别所有题目
- 批量查询答案（参考chaoxing.js的批量处理）
- 自动填充答案
- 自动提交（可选）
- 正确率统计（参考chaoxing.js的正确率计算）

**第三层：高级管理功能（控制面板，可选）**
- 答题日志查看（参考chaoxing.js的日志系统）
- 本地答案库管理（GM_getValue导入/导出）
- 配置管理（参考chaoxing.js的配置界面）
- 使用统计（API Key使用情况）
- 答案导入/导出
- 题目列表展示（参考chaoxing.js的QuestionTable）

### 3. 核心功能模块设计

#### 3.1 题目识别模块

**功能：**
- 自动识别不同平台的题目DOM结构
- 提取题目ID（questionId）
- 提取题目类型（0=单选，1=多选，2=判断，3=填空，4=简答）
- 提取题目内容文本
- 提取选项内容（选择题）
- 识别题目状态（已答/未答）

**识别策略（传智播客）：**
- 题目容器：`.question-item` 或 `[data-id]`
- 题目内容：`.question-title-box .myEditorTxt`
- 题目类型：从DOM结构或数据属性判断
- 选项容器：`.question-option-item`
- 已答状态：检查选中状态或输入值

**识别策略（超星学习通）：**
- 题目类型：`.quest-category`
- 题目内容：`.quest-stem`
- 选项容器：`.quest-option-top`

#### 3.2 答案查询模块（双重策略）

**融合 auto_answer.user.js 和 chaoxing.js 的查询策略：**

**查询优先级：**
1. **本地答案库查询**（优先，快速，参考 auto_answer.user.js）
   - 从本地JSON文件加载的答案库（danxuan.json, duoxuan.json等）
   - 支持 questionId 精确匹配（最快）
   - 支持题目内容文本匹配（次快）
   - 支持从 solution 字段提取答案
   - 查询速度快（< 10ms），不消耗API次数
   - 支持多文件合并查询（fasfa.json格式）

2. **云端API查询**（补充，准确，参考 chaoxing.js）
   - 本地库未找到时调用
   - 使用API Key认证（X-API-Key header）
   - 支持相似度匹配（模糊查询）
   - 返回结果包含置信度
   - 返回结果可缓存到本地（可选）
   - 支持跨平台查询

**查询流程：**
```
题目识别 
  ↓
提取 questionId 和题目内容
  ↓
本地库查询（questionId精确匹配）
  ↓ 找到？
  ├─ 是 → 返回结果（标记来源：本地库）
  └─ 否 → 本地库查询（题目内容文本匹配）
         ↓ 找到？
         ├─ 是 → 返回结果（标记来源：本地库-文本匹配）
         └─ 否 → 云端API查询（使用API Key）
                ↓ 找到？
                ├─ 是 → 返回结果并缓存（标记来源：云端API，显示置信度）
                └─ 否 → 返回未找到，提示可上传题目
```

**查询结果格式：**
```javascript
{
  code: 1,  // 1=找到，0=未找到
  answer: ["A", "B"],  // 答案数组
  solution: "解析内容",  // 解析（可选）
  source: "local" | "local-text" | "api",  // 来源
  confidence: 0.95,  // 置信度（仅API查询）
  questionId: "xxx",  // 题目ID
  platform: "czbk"  // 平台
}
```

#### 3.3 查询按钮模块

**设计参考 chaoxing.js：**
- **位置**：右下角固定悬浮（`position: fixed; bottom: 20px; right: 20px;`）
- **样式**：圆角按钮，蓝色背景，白色文字
- **状态**：
  - 默认：显示"🔍 查询答案"
  - 查询中：显示"查询中..."，禁用按钮
  - 查询完成：恢复原状

**功能：**
- 点击查询当前页面所有题目
- 支持快捷键触发（如 Ctrl+Q）
- 显示查询进度（可选）

#### 3.4 结果展示模块

**设计参考 chaoxing.js：**
- **位置**：右上角弹窗（`position: fixed; top: 20px; right: 20px;`）
- **样式**：白色背景，圆角，阴影，可关闭
- **内容**：表格形式展示
  - 题目 | 题目内容
  - 答案 | 答案内容
  - 状态 | 查询结果/填充状态
  - 来源 | 本地库/云端API

**功能：**
- 显示查询结果
- 支持复制答案
- 支持关闭弹窗
- 支持查看详情

#### 3.5 自动填充模块

**融合 auto_answer.user.js 和 chaoxing.js 的填充逻辑：**

**题型支持（传智播客）：**
1. **单选题（questionType=0）**
   - 查找：`input[type="radio"][value="${answer}"]`
   - 操作：触发 click 事件
   - 验证：检查是否选中

2. **多选题（questionType=1）**
   - 查找：`input[type="checkbox"][value="${answer}"]`
   - 操作：遍历所有答案，逐个点击
   - 验证：检查所有答案是否都选中

3. **判断题（questionType=2）**
   - 查找：`input[type="radio"][value="${answer}"]`
   - 操作：触发 click 事件
   - 验证：检查是否选中

4. **填空题（questionType=3）**
   - 查找：`input.tk_input[data-questionid="${questionId}"]`
   - 操作：设置 value 并触发 input/change 事件
   - 支持多空：按答案数组顺序填充

5. **简答题（questionType=4）**
   - 查找：`.editor-box` 内的编辑器
   - 支持多种编辑器类型：
     - textarea：直接设置 value
     - iframe：操作 iframe 内的 contentEditable
     - contentEditable：直接设置 textContent
   - 操作：设置内容并触发相应事件

**题型支持（超星学习通）：**
- 单选/多选：匹配选项文本（`.quest-option-top`），点击对应选项
- 自动提交：查找提交按钮并点击（可选）

**填充策略：**
- **用户配置**：
  - 自动填充开关（默认关闭）
  - 自动提交开关（默认关闭）
  - 跳过已答题开关（默认开启）
  - 填充延迟设置（默认500ms，避免过快）

- **填充流程**：
  1. 查询到答案后，检查是否启用自动填充
  2. 如果启用，检查题目是否已答（可选跳过）
  3. 执行填充操作
  4. 等待延迟（确保DOM更新）
  5. 验证填充结果
  6. 显示填充状态

- **错误处理**：
  - 找不到对应选项：提示用户手动选择
  - 填充失败：记录日志，提示用户
  - 部分填充成功：显示成功数量

- **安全考虑**：
  - 默认不启用自动填充（用户需手动开启）
  - 填充前可显示确认提示（可选）
  - 填充后允许用户修改
  - 不自动提交（除非用户明确启用）

#### 3.6 控制面板模块（可选，参考完整版chaoxing.js，使用Vue 3 + Antdv）

**架构设计（参考chaoxing.js的Vue组件化，改用Antdv）：**
- **UI框架**：Vue 3 + Ant Design Vue（Antdv）
- **状态管理**：Pinia（可选）或原生状态管理
- **显示方式**：可拖拽悬浮面板（参考chaoxing.js的layout组件）
- **组件库**：Ant Design Vue（a-button、a-table、a-tabs、a-input等）

**功能模块（使用Antdv组件实现）：**

1. **首页/日志标签页**（使用a-list或a-timeline组件）
   - 实时日志显示
   - 日志类型：success、info、warning、error（Antdv的Tag组件）
   - 时间戳显示
   - 自动滚动（a-scrollbar或自定义）

2. **答题标签页**（使用a-table组件）
   - 题目列表表格展示（a-table）
   - 显示题目内容和答案
   - API Key配置输入框（a-input）
   - 支持查看详情（a-modal或a-drawer）

3. **设置标签页**（使用a-form组件）
   - **平台配置**：
     - 传智播客特定配置
     - 超星学习通特定配置（如需要）
   - **答题设置**（a-form + a-switch + a-input-number）：
     - 自动答题开关（a-switch）
     - 自动提交开关（a-switch）
     - 答题间隔（秒）（a-input-number）
     - 正确率阈值（自动提交）（a-input-number）
     - 相似度匹配开关（a-switch）
   - **其他参数**：
     - 跳过已答题（a-switch）
     - 答题延迟（a-input-number）

4. **答案库管理**（可选）
   - 本地答案库查看（GM_getValue）
   - 答案库导入/导出（JSON格式）
   - 答案库去重
   - 答案库统计

5. **使用统计**
   - API Key使用情况
   - 今日查询次数
   - 剩余次数
   - 查询成功率
   - 正确率统计

**轻量级实现方案（不使用Vue）：**
- 使用原生JavaScript + CSS
- 简单的模态框或侧边栏
- 基础配置表单
- 简化版日志显示

**Antdv组件使用示例：**
- `a-tabs`、`a-tab-pane`：标签页切换
- `a-table`、`a-table-column`：题目列表表格
- `a-form`、`a-form-item`：配置表单
- `a-switch`：开关组件
- `a-input`、`a-input-number`：输入框
- `a-button`：按钮
- `a-card`：卡片容器
- `a-tag`：标签（日志类型）
- `a-modal`：模态框
- `a-drawer`：抽屉（详情查看）
- `a-divider`：分割线
- `a-empty`：空状态
- `a-list`、`a-list-item`：日志列表
- `a-timeline`、`a-timeline-item`：时间线日志
- `a-alert`：提示信息
- `a-spin`：加载状态
- `a-message`：消息提示

**Antdv引入方式（油猴脚本）：**
```javascript
// @require https://unpkg.com/vue@3/dist/vue.global.prod.js
// @require https://unpkg.com/ant-design-vue@4/dist/antd.min.js
// @resource AntdvCSS https://unpkg.com/ant-design-vue@4/dist/reset.css
```

**Shadow DOM隔离（参考chaoxing.js的Shadow DOM实现）：**
- 使用Shadow DOM隔离样式，避免与页面样式冲突
- 注入Antdv CSS到Shadow DOM
- 确保组件样式正常显示

### 4. 用户交互流程

#### 4.1 首次使用流程（轻量级方案）

1. 用户安装油猴脚本
2. 打开答题页面（传智播客）
3. 脚本自动初始化
4. 右下角出现"🔍 查询答案"按钮
5. 首次点击，提示输入API Key（或从GM_getValue读取）
6. 输入API Key并保存（使用GM_setValue）
7. 开始使用查询功能

#### 4.1.1 首次使用流程（现代化方案，参考chaoxing.js）

1. 用户安装油猴脚本
2. 打开答题页面
3. 脚本自动初始化，加载Vue组件
4. 显示可拖拽控制面板（参考chaoxing.js的layout）
5. 在"设置"标签页配置API Key
6. 在"答题"标签页查看题目列表
7. 自动开始答题或手动触发

#### 4.2 日常使用流程（简洁模式，轻量级）

1. 用户打开答题页面
2. 脚本自动识别页面上的题目
3. 用户点击右下角"🔍 查询答案"按钮
4. 显示"查询中..."状态
5. 优先查询本地答案库（GM_getValue）
6. 本地未找到则调用云端API
7. 云端未找到则调用AI答题（如启用）
8. 右上角弹窗显示查询结果
9. 用户可手动填充答案
10. 或启用自动填充功能

#### 4.3 批量自动答题流程（完整模式，参考chaoxing.js）

1. 用户打开答题页面
2. 脚本自动识别所有题目（参考chaoxing.js的parseHtml）
3. 在控制面板查看题目列表（参考QuestionTable）
4. 启用"自动答题"配置
5. 脚本自动批量查询答案（参考chaoxing.js的init方法）
6. 逐个填充答案（参考chaoxing.js的fillQuestion）
7. 显示答题进度和日志（参考chaoxing.js的日志系统）
8. 计算正确率（参考chaoxing.js的correctNum统计）
9. 根据正确率决定是否自动提交（参考chaoxing.js的自动提交逻辑）
10. 完成后提示

#### 4.4 刷课流程（传智播客）

1. 用户打开视频播放页面
2. 脚本检测到视频页面（`.preview_play-container`）
3. 左下角显示"🚀 一键完成"按钮
4. 点击按钮，自动完成课程
5. 尝试调用`finishWxCourse()`函数
6. 或查找并点击完成按钮
7. 或快进视频到结尾

#### 4.4 错误处理流程

1. **网络错误**：提示"连接失败，请检查网络"，仅使用本地库
2. **API Key无效**：提示"API Key无效，请重新配置"，跳转配置页面
3. **次数超限**：提示"今日查询次数已用完"，仅使用本地库
4. **未找到答案**：提示"未找到答案"，显示"可尝试上传题目"提示
5. **题目识别失败**：提示"无法识别题目"，支持手动输入题目查询

### 5. 平台适配器设计（参考chaoxing.js的BaseQuestionHandler）

#### 5.1 适配器基类设计（参考chaoxing.js）

**BaseQuestionHandler基类（参考chaoxing.js的4934行）：**
- **核心方法**：
  - `parseHtml()`：解析HTML，提取题目
  - `fillQuestion()`：填充答案
  - `removeHtml()`：清理HTML标签
  - `clean()`：清理题目文本
- **题目类型映射**：questionType对象
- **日志系统**：集成useLogStore
- **题目存储**：集成useQuestionStore

#### 5.2 传智播客适配器（CzbkQuestionHandler）

**参考 auto_answer.user.js 和 chaoxing.js的设计：**

**题目识别**：
- 题目容器：`.question-item` 或 `[data-id]`
- 题目内容：`.question-title-box .myEditorTxt`
- 题目ID：`data-id` 属性
- 题目类型：从DOM结构判断
  - 单选：`input[type="radio"]`（数量>2）
  - 多选：`input[type="checkbox"]`
  - 判断：`input[type="radio"]`（数量=2）
  - 填空：`input.tk_input`
  - 简答：`.editor-box`

**答案填充**（参考chaoxing.js的fillQuestion逻辑）：
- 单选/判断：`input[type="radio"][value="${answer}"]` → click()
- 多选：遍历答案数组，逐个点击checkbox
- 填空：设置input.value并触发事件
- 简答：操作编辑器（textarea/iframe/contentEditable）

**选项提取**（参考chaoxing.js的extractOptions）：
- 选项容器：`.question-option-item`
- 选项文本提取
- 选项对象映射（文本 → DOM元素）

#### 5.3 超星学习通适配器（CxQuestionHandler）

**参考完整版chaoxing.js的CxQuestionHandler（5087行）：**
- 支持章节作业（zj）、作业（zy）、考试（ks）
- 支持iframe嵌套题目
- 字体解密功能（参考chaoxing.js的decrypt函数）
- 相似度匹配（参考chaoxing.js的findBestMatch）

#### 5.4 适配器管理器

**设计模式（参考chaoxing.js）：**
- 工厂模式创建适配器
- 根据URL自动选择适配器
- 支持多平台切换

**功能：**
- 自动检测当前平台
- 加载对应适配器
- 支持多平台同时存在（不同页面）
- 支持自定义适配器（未来扩展）

### 6. 配置管理设计

#### 6.1 本地存储配置（使用GM_setValue/GM_getValue）

**存储内容：**
- `apiKey`：API Key（加密存储）
- `autoAnswer`：自动答题开关（boolean）
- `autoSubmit`：自动提交开关（boolean）
- `answerDelay`：答题延迟（毫秒）
- `skipAnswered`：跳过已答题（boolean）
- `showControlPanel`：显示控制面板（boolean）
- `queryHistory`：查询历史（数组，可选）
- `localAnswerDB`：本地答案库缓存（JSON字符串）

#### 6.2 配置界面（使用Antdv组件）

**简洁模式：**
- 点击查询按钮旁的设置图标（a-button + a-icon）
- 弹出简单配置框（a-modal）
- 仅显示关键配置项（a-form + a-form-item）

**完整模式（Vue 3 + Antdv控制面板）：**
- 可拖拽悬浮面板（a-card，自定义拖拽逻辑）
- 标签页切换（a-tabs）
- 配置表单（a-form + a-form-item）
- 开关组件（a-switch）
- 数字输入（a-input-number）
- 文本输入（a-input）

**Antdv组件映射：**
- 配置表单：`a-form` + `a-form-item` + `a-switch` / `a-input-number`
- 日志显示：`a-list` 或 `a-timeline` + `a-tag`（类型标签）
- 题目列表：`a-table` + `a-table-column`
- 按钮操作：`a-button` + `a-icon`
- 消息提示：`a-message`（成功/错误提示）
- 加载状态：`a-spin`（查询中显示）

**完整模式（控制面板）：**
- 完整的配置界面
- 分类管理
- 实时预览效果

### 7. Vue 3 + Ant Design Vue 架构设计

#### 7.1 技术栈选择

**核心框架：**
- **Vue 3**：渐进式JavaScript框架，Composition API
- **Ant Design Vue 4.x**：企业级UI组件库，中文文档完善
- **Pinia**（可选）：Vue 3官方推荐的状态管理库

**引入方式（油猴脚本）：**
```javascript
// ==UserScript==
// @require https://unpkg.com/vue@3/dist/vue.global.prod.js
// @require https://unpkg.com/pinia@2/dist/pinia.iife.min.js
// @require https://unpkg.com/ant-design-vue@4/dist/antd.min.js
// @resource AntdvCSS https://unpkg.com/ant-design-vue@4/dist/reset.css
// ==/UserScript==
```

#### 7.2 组件架构设计

**主应用组件（参考chaoxing.js的layout）：**
- **可拖拽面板**：使用a-card + 自定义拖拽逻辑
- **标签页切换**：a-tabs + a-tab-pane
- **Shadow DOM隔离**：避免样式冲突

**核心组件设计：**

1. **ScriptHome组件（日志标签页）**
   - 使用 `a-list` 或 `a-timeline` 显示日志
   - `a-tag` 显示日志类型（success/info/warning/error）
   - 自动滚动功能
   - 时间戳格式化显示

2. **QuestionTable组件（答题标签页）**
   - `a-table` 展示题目列表
   - `a-table-column` 定义列（序号、题目、答案）
   - `a-input` 输入API Key
   - `a-empty` 空状态提示

3. **ScriptSetting组件（设置标签页）**
   - `a-form` + `a-form-item` 表单布局
   - `a-switch` 开关组件（自动答题、自动提交等）
   - `a-input-number` 数字输入（答题间隔、正确率阈值）
   - `a-divider` 分割线（分组显示）

4. **Layout组件（主容器）**
   - `a-card` 卡片容器
   - 自定义拖拽逻辑（参考chaoxing.js的drag实现）
   - 最小化/最大化功能
   - Shadow DOM样式隔离

#### 7.3 状态管理设计（Pinia）

**Store设计（参考chaoxing.js的useConfigStore）：**

1. **useConfigStore（配置管理）**
   - 存储用户配置
   - 自动持久化到GM_setValue
   - 配置版本管理
   - 配置迁移逻辑

2. **useLogStore（日志管理）**
   - 日志数组存储
   - 添加日志方法（addLog）
   - 日志类型：success、info、warning、error
   - 自动限制日志数量

3. **useQuestionStore（题目管理）**
   - 题目列表存储
   - 添加题目方法（addQuestion）
   - 清空题目方法（clearQuestion）

#### 7.4 Shadow DOM样式隔离

**实现方式（参考chaoxing.js的6020行）：**
- 创建Shadow DOM容器
- 注入Antdv CSS到Shadow DOM
- 确保组件样式正常显示
- 避免与页面样式冲突

**样式注入：**
```javascript
const shadow = shadowRoot.attachShadow({ mode: 'closed' });
const sheet = new CSSStyleSheet();
sheet.replace(antdvCSS); // 从@resource获取
shadow.adoptedStyleSheets = [sheet];
```

#### 7.5 组件通信设计

**父子组件通信：**
- Props传递数据
- Events触发事件
- Provide/Inject（跨层级）

**状态共享：**
- Pinia Store（全局状态）
- GM_getValue/GM_setValue（持久化）

#### 7.6 响应式设计

**布局适配：**
- 使用Antdv的响应式栅格系统（a-row、a-col）
- 面板宽度自适应
- 移动端适配（可选）

**交互优化：**
- 加载状态（a-spin）
- 消息提示（a-message）
- 确认对话框（a-modal.confirm）

### 8. 安全与隐私设计

#### 7.1 API Key安全

- 使用GM_setValue存储（Tampermonkey安全存储）
- 不记录到浏览器localStorage
- 支持快速清除
- 传输时使用HTTPS（如果后端支持）

#### 7.2 隐私保护

- 题目内容仅发送到后端API（8.138.237.189:8000）
- 不发送到第三方服务
- 本地答案库不上传
- 答题日志仅本地存储

#### 7.3 防滥用机制

- **前端限流**：相同题目5秒内不重复查询
- **请求去重**：批量查询时合并相同题目
- **错误重试**：网络错误时自动重试（最多3次）
- **降级策略**：API失败时仅使用本地库

### 9. 性能优化设计

#### 8.1 本地答案库优化

- 首次加载时解析JSON并建立索引
- 使用Map结构快速查找（questionId -> answer）
- 支持增量更新
- 定期清理无效数据

#### 8.2 查询优化

**查询策略（融合两个脚本的优势）：**

1. **本地优先策略**
   - 首次加载时解析本地JSON答案库（danxuan.json, duoxuan.json等）
   - 建立内存索引（Map结构）：questionId -> answer
   - 查询时优先在本地库查找（毫秒级响应）
   - 本地未找到再调用云端API

2. **云端API查询**
   - 异步查询，不阻塞页面
   - 支持相似度匹配（模糊查询）
   - 查询结果自动缓存到本地（可选）
   - 失败时降级到仅使用本地库

3. **查询结果缓存**
   - 相同题目5秒内不重复查询
   - 缓存结果存储在内存中
   - 页面刷新后缓存清空

4. **批量查询优化**
   - 批量答题时，相同题目去重
   - 支持并发查询（限制并发数，避免过载）
   - 显示查询进度条

5. **性能指标**
   - 本地查询：< 10ms
   - 云端查询：< 500ms（网络正常）
   - 批量查询：平均每个题目 < 100ms

#### 8.3 传智播客刷课页面适配

**页面识别：**
- 视频播放页面：包含 `.preview_play-container` 和视频播放器
- 答题页面：包含 `.question-item` 或题目相关DOM
- 课程目录页面：包含 `.chapter-points-box`

**功能适配：**

1. **视频页面**
   - 不显示查询按钮（避免干扰）
   - 仅在答题页面显示功能

2. **答题页面**
   - 自动识别题目类型和内容
   - 显示查询按钮和结果弹窗
   - 支持自动填充答案

3. **页面切换监听**
   - 监听路由变化（SPA应用）
   - 页面切换时重新初始化
   - 保持API Key配置状态

**DOM选择器（传智播客）：**
- 题目容器：`.question-item` 或 `[data-id]`
- 题目内容：`.question-title-box .myEditorTxt`
- 题目ID：`data-id` 属性
- 选项容器：`.question-option-item`
- 单选按钮：`input[type="radio"]`
- 多选按钮：`input[type="checkbox"]`
- 填空输入：`input.tk_input[data-questionid]`
- 简答编辑器：`.editor-box` 内的 `textarea` 或 `iframe`

#### 8.4 超星学习通页面适配

**页面识别：**
- 答题页面：包含 `.quest-category` 和 `.quest-stem`
- 课程页面：包含 `.page-WH`

**功能适配：**
- 参考 chaoxing.js 的设计
- 固定按钮在右下角
- 结果弹窗在右上角
- 支持自动填充和自动提交

---
