# 服务器承载能力分析

## 服务器配置
- **CPU**: 1核
- **内存**: 1GB
- **带宽**: 200Mbps (25MB/s)

## 资源消耗分析

### 1. 内存消耗
- **FastAPI + Uvicorn**: ~50-80MB
- **SQLite数据库**: ~10-50MB（取决于数据量）
- **Python运行时**: ~30-50MB
- **系统预留**: ~200MB
- **可用内存**: ~700-800MB

### 2. CPU消耗
- **单核性能**: 有限，需要合理配置并发
- **数据库查询**: 轻量级（SQLite）
- **纠错逻辑**: CPU密集型（JSON解析、字符串处理）

### 3. 带宽消耗
- **单个请求**: 平均 5-50KB（取决于res.json大小）
- **200Mbps带宽**: 理论最大 25MB/s = 25000KB/s
- **理论并发**: 500-5000 请求/秒（取决于请求大小）

## 并发能力估算

### 场景1：轻量级请求（搜索答案）
- **请求大小**: ~1KB
- **响应大小**: ~2KB
- **处理时间**: ~50-100ms
- **单核并发**: ~10-20 请求/秒
- **理论最大**: 200-400 并发用户（考虑延迟）

### 场景2：中等请求（上传题目）
- **请求大小**: ~10-50KB
- **响应大小**: ~2KB
- **处理时间**: ~200-500ms
- **单核并发**: ~2-5 请求/秒
- **理论最大**: 40-100 并发用户

### 场景3：重请求（批改响应处理）
- **请求大小**: ~50-200KB（res.json）
- **响应大小**: ~5-20KB
- **处理时间**: ~500-2000ms（JSON解析 + 纠错计算）
- **单核并发**: ~0.5-2 请求/秒
- **理论最大**: 10-40 并发用户

## 实际承载能力（保守估算）

### 混合场景（实际使用）
假设：
- 70% 轻量级请求（搜索）
- 20% 中等请求（上传）
- 10% 重请求（纠错）

**单核1GB内存服务器**：
- **并发用户数**: **30-50 人**
- **峰值请求**: **100-200 请求/分钟**
- **平均响应时间**: **200-500ms**

## 优化建议

### 1. 服务器配置优化

#### 使用 Gunicorn + Uvicorn Workers（推荐）
```bash
# 安装 gunicorn
pip install gunicorn

# 启动（2个worker，适合1核CPU）
gunicorn main:app -w 2 -k uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000 --timeout 120
```

**优势**：
- 多进程处理，提高并发能力
- 单个worker崩溃不影响其他worker
- 适合1核CPU（2个worker可以充分利用CPU）

**预期提升**：
- 并发用户数：**50-80 人**（提升60%）

#### 使用 Nginx 反向代理（可选）
```nginx
upstream backend {
    server 127.0.0.1:8000;
}

server {
    listen 80;
    server_name your-domain.com;
    
    location / {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

**优势**：
- 静态文件缓存
- 请求负载均衡
- 压缩响应（减少带宽）

### 2. 代码优化

#### 异步处理
- ✅ 已使用 FastAPI（异步框架）
- ✅ 已使用 async/await
- ✅ 数据库查询异步化

#### 缓存优化
- **答案尝试缓存**: 当前使用内存缓存，可扩展为Redis（如果需要多服务器）
- **题目查询缓存**: 可添加Redis缓存热门题目（减少数据库查询）

#### 数据库优化
- **索引优化**: 确保 `question_id`, `api_key` 有索引
- **连接池**: SQLite连接池大小限制（避免内存溢出）

### 3. 功能优化

#### 批改响应处理优化
- **流式处理**: 对于大型res.json，可以流式解析（减少内存占用）
- **批量处理**: 合并多个请求的纠错计算（减少CPU开销）

#### 请求限流
- **按API Key限流**: 防止单个用户占用过多资源
- **全局限流**: 保护服务器不被过载

## 推荐配置

### 最小配置（1核1GB）
```bash
# 使用 Gunicorn + 2 workers
gunicorn main:app -w 2 -k uvicorn.workers.UvicornWorker \
    --bind 0.0.0.0:8000 \
    --timeout 120 \
    --max-requests 1000 \
    --max-requests-jitter 100
```

**预期性能**：
- 并发用户：**50-80 人**
- 峰值请求：**150-300 请求/分钟**

### 升级建议

#### 升级到 2核2GB
- 并发用户：**100-150 人**
- 可使用 4 workers

#### 升级到 4核4GB
- 并发用户：**200-300 人**
- 可使用 8 workers
- 可添加 Redis 缓存

## 监控指标

### 关键指标
1. **内存使用率**: < 80%
2. **CPU使用率**: < 70%（平均）
3. **响应时间**: P95 < 1000ms
4. **错误率**: < 1%

### 告警阈值
- 内存使用 > 90%: 告警
- CPU使用 > 90% (持续5分钟): 告警
- 响应时间 P95 > 2000ms: 告警
- 错误率 > 5%: 告警

## 总结

### 当前配置（1核1GB，200Mbps）
- **推荐并发用户数**: **30-50 人**
- **峰值请求**: **100-200 请求/分钟**
- **适用场景**: 小规模使用、个人项目、测试环境

### 优化后（Gunicorn + 2 workers）
- **推荐并发用户数**: **50-80 人**
- **峰值请求**: **150-300 请求/分钟**
- **适用场景**: 中小规模使用、小团队项目

### 如需更高性能
- **升级到 2核2GB**: 支持 100-150 并发用户
- **升级到 4核4GB**: 支持 200-300 并发用户
- **添加 Redis**: 进一步提升查询性能

